<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Browser PDF Editor</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        .toolbar {
            display: flex;
            gap: 10px;
            padding: 10px;
            background-color: #f0f0f0;
            border-bottom: 1px solid #ccc;
            flex-wrap: wrap;
        }
        .main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        .canvas-container {
            flex: 1;
            overflow: auto;
            position: relative;
            background-color: #808080;
            display: flex;
            justify-content: center;
            padding: 20px;
        }
        #pdf-container {
            background-color: white;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
            position: relative;
        }
        button {
            padding: 8px 12px;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
        }
        button:hover {
            background-color: #45a049;
        }
        button.active {
            background-color: #2E7D32;
        }
        #file-input {
            display: none;
        }
        #image-input {
            display: none;
        }
        .button-group {
            display: flex;
            gap: 5px;
            align-items: center;
        }
        .status {
            margin-left: auto;
            padding: 8px;
            color: #555;
        }
        .pdf-page {
            margin-bottom: 20px;
            position: relative;
        }
        .pdf-canvas {
            position: absolute;
            top: 0;
            left: 0;
        }
        .fabric-canvas-container {
            position: absolute;
            top: 0;
            left: 0;
        }
        .text-options {
            display: none;
            gap: 5px;
            align-items: center;
            background-color: #e0e0e0;
            padding: 5px;
            border-radius: 4px;
        }
        .text-options select {
            padding: 5px;
            border-radius: 3px;
            border: 1px solid #ccc;
        }
        .text-options.active {
            display: flex;
        }
    </style>
</head>
<body>
    <div class="toolbar">
        <div class="button-group">
            <button id="load-pdf">Load PDF</button>
            <input type="file" id="file-input" accept=".pdf"/>
        </div>
        <div class="button-group">
            <button id="text-tool">Add Text</button>
            <button id="image-tool">Add Image</button>
            <input type="file" id="image-input" accept="image/*"/>
            <button id="red-box-tool">Draw Box</button>
            <button id="red-arrow-tool">Draw Arrow</button>
            <button id="eraser-tool">Pen</button>
        </div>
        <div class="text-options" id="text-options">
            <select id="font-family">
                <option value="Arial">Arial</option>
                <option value="Times New Roman">Times New Roman</option>
                <option value="Courier New">Courier New</option>
                <option value="Georgia">Georgia</option>
                <option value="Verdana">Verdana</option>
                <option value="Impact">Impact</option>
            </select>
            <select id="font-size">
                <option value="10">10</option>
                <option value="12">12</option>
                <option value="14">14</option>
                <option value="16" selected>16</option>
                <option value="18">18</option>
                <option value="20">20</option>
                <option value="24">24</option>
                <option value="28">28</option>
                <option value="32">32</option>
                <option value="36">36</option>
                <option value="48">48</option>
            </select>
            <select id="font-color">
                <option value="black">Black</option>
                <option value="red">Red</option>
                <option value="blue">Blue</option>
                <option value="green">Green</option>
                <option value="purple">Purple</option>
            </select>
        </div>
        <div class="button-group">
            <button id="undo-button">Undo</button>
            <button id="clear-button">Clear All</button>
        </div>
        <div class="button-group">
            <button id="save-pdf">Save PDF</button>
        </div>
        <div class="status" id="status">No PDF loaded</div>
    </div>
    <div class="main-container">
        <div class="canvas-container" id="canvas-container">
            <div id="pdf-container"></div>
        </div>
    </div>

    <script>
        // Set worker path for PDF.js
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';
        
        // Initialize variables
        let pdfDoc = null;
        let pdfPages = [];
        let currentPage = 1;
        let totalPages = 0;
        let fabricCanvases = [];
        let currentTool = null;
        let pdfFile = null;
        let imageFile = null;
        let isDrawing = false;
        let startX, startY;
        let currentTextBox = null;
        let objectsHistory = [];
        let pdfData = null;
        let imgInstance = null;
        let isImagePlacement = false;
        let eraserBrush = null;
        let selectedObjects = [];
        
        // Text options
        let fontFamily = 'Arial';
        let fontSize = 16;
        let fontColor = 'black';
        
        // Button elements
        const loadPdfBtn = document.getElementById('load-pdf');
        const fileInput = document.getElementById('file-input');
        const textToolBtn = document.getElementById('text-tool');
        const imageToolBtn = document.getElementById('image-tool');
        const imageInput = document.getElementById('image-input');
        const redBoxToolBtn = document.getElementById('red-box-tool');
        const redArrowToolBtn = document.getElementById('red-arrow-tool');
        const eraserToolBtn = document.getElementById('eraser-tool');
        const undoBtn = document.getElementById('undo-button');
        const clearBtn = document.getElementById('clear-button');
        const savePdfBtn = document.getElementById('save-pdf');
        const statusEl = document.getElementById('status');
        const pdfContainer = document.getElementById('pdf-container');
        const canvasContainer = document.getElementById('canvas-container');
        
        // Text options elements
        const textOptions = document.getElementById('text-options');
        const fontFamilySelect = document.getElementById('font-family');
        const fontSizeSelect = document.getElementById('font-size');
        const fontColorSelect = document.getElementById('font-color');
        
        // Tool button event listeners
        loadPdfBtn.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', loadPDF);
        textToolBtn.addEventListener('click', () => setActiveTool('text'));
        imageToolBtn.addEventListener('click', () => setActiveTool('image'));
        imageInput.addEventListener('change', handleImageInput);
        redBoxToolBtn.addEventListener('click', () => setActiveTool('red-box'));
        redArrowToolBtn.addEventListener('click', () => setActiveTool('red-arrow'));
        eraserToolBtn.addEventListener('click', () => setActiveTool('eraser'));
        undoBtn.addEventListener('click', undoLastAction);
        clearBtn.addEventListener('click', clearAllAnnotations);
        savePdfBtn.addEventListener('click', savePDF);
        
        // Text options event listeners
        fontFamilySelect.addEventListener('change', updateTextOptions);
        fontSizeSelect.addEventListener('change', updateTextOptions);
        fontColorSelect.addEventListener('change', updateTextOptions);
        
        // Update text options
        function updateTextOptions() {
            fontFamily = fontFamilySelect.value;
            fontSize = parseInt(fontSizeSelect.value);
            fontColor = fontColorSelect.value;
            
            // If text is currently selected, update its properties
            fabricCanvases.forEach(canvas => {
                const activeObject = canvas.getActiveObject();
                if (activeObject && activeObject.type === 'i-text') {
                    activeObject.set({
                        fontFamily: fontFamily,
                        fontSize: fontSize,
                        fill: fontColor
                    });
                    canvas.renderAll();
                }
            });
        }
        
        // Set active tool and update UI
        function setActiveTool(tool) {
            currentTool = tool;
            
            // Reset active state for all buttons
            textToolBtn.classList.remove('active');
            imageToolBtn.classList.remove('active');
            redBoxToolBtn.classList.remove('active');
            redArrowToolBtn.classList.remove('active');
            eraserToolBtn.classList.remove('active');
            textOptions.classList.remove('active');
            
            // Reset eraser mode on all canvases
            fabricCanvases.forEach(canvas => {
                canvas.isDrawingMode = false;
                if (eraserBrush) {
                    canvas.freeDrawingBrush = canvas._brushes.pencil;
                }
            });
            
            // Set active state for selected tool
            switch(tool) {
                case 'text':
                    textToolBtn.classList.add('active');
                    textOptions.classList.add('active');
                    break;
                case 'image':
                    imageToolBtn.classList.add('active');
                    if (tool === 'image') {
                        imageInput.click();
                    }
                    break;
                case 'red-box':
                    redBoxToolBtn.classList.add('active');
                    break;
                case 'red-arrow':
                    redArrowToolBtn.classList.add('active');
                    break;
                case 'eraser':
                    eraserToolBtn.classList.add('active');
                    fabricCanvases.forEach(canvas => {
                        initEraser(canvas);
                    });
                    break;
            }
            
            updateStatus(`Tool: ${tool}`);
        }
        
        // Initialize eraser brush for a canvas
        function initEraser(canvas) {
            // Store the current selection
            selectedObjects = [];
            canvas.getActiveObjects().forEach(obj => {
                selectedObjects.push(obj);
            });
            
            // Enable eraser mode
            canvas.isDrawingMode = true;
            
            // Create eraser brush if it doesn't exist
            if (!canvas._brushes) {
                canvas._brushes = {};
                canvas._brushes.pencil = canvas.freeDrawingBrush;
            }
            
            // Create eraser brush if not already created
            if (!canvas._brushes.eraser) {
                canvas._brushes.eraser = new fabric.EraserBrush(canvas);
                canvas._brushes.eraser.width = 20;
                canvas._brushes.eraser.color = 'rgba(255,255,255,0.5)';
            }
            
            // Set eraser as active brush
            canvas.freeDrawingBrush = canvas._brushes.eraser;
            
            // Add custom eraser functionality since EraserBrush may not be available
            // This is a simple implementation that removes objects on click
            canvas.on('mouse:down', function(options) {
                if (currentTool === 'eraser') {
                    const pointer = canvas.getPointer(options.e);
                    const objects = canvas.getObjects();
                    
                    for (let i = objects.length - 1; i >= 0; i--) {
                        if (objects[i].containsPoint(pointer)) {
                            // Add to undo history before removing
                            objectsHistory.push({canvas: canvas, object: objects[i], action: 'remove'});
                            canvas.remove(objects[i]);
                            canvas.renderAll();
                            break;
                        }
                    }
                }
            });
        }
        
        // Load PDF file
        async function loadPDF(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            pdfFile = file;
            
            // Clear previous canvases
            pdfContainer.innerHTML = '';
            fabricCanvases = [];
            pdfPages = [];
            objectsHistory = [];
            
            updateStatus('Loading PDF...');
            
            const fileReader = new FileReader();
            fileReader.onload = async function(event) {
                try {
                    const typedArray = new Uint8Array(event.target.result);
                    pdfData = typedArray;
                    
                    // Load the PDF document
                    pdfDoc = await pdfjsLib.getDocument({data: typedArray}).promise;
                    totalPages = pdfDoc.numPages;
                    
                    // Render all pages of the PDF
                    for (let pageNum = 1; pageNum <= totalPages; pageNum++) {
                        await renderPage(pageNum);
                    }
                    
                    updateStatus(`PDF loaded: ${file.name} (${totalPages} pages)`);
                } catch (error) {
                    console.error('Error loading PDF:', error);
                    updateStatus('Error loading PDF: ' + error.message);
                }
            };
            
            fileReader.readAsArrayBuffer(file);
        }
        
        // Render a single PDF page
        async function renderPage(pageNum) {
            try {
                // Get the page
                const page = await pdfDoc.getPage(pageNum);
                pdfPages.push(page);
                
                // Get the viewport
                const viewport = page.getViewport({scale: 1.5});
                
                // Create a container for this page
                const pageContainer = document.createElement('div');
                pageContainer.className = 'pdf-page';
                pageContainer.style.width = `${viewport.width}px`;
                pageContainer.style.height = `${viewport.height}px`;
                pageContainer.dataset.pageNum = pageNum;
                pdfContainer.appendChild(pageContainer);
                
                // Create canvas for PDF rendering
                const pdfCanvas = document.createElement('canvas');
                pdfCanvas.className = 'pdf-canvas';
                pdfCanvas.width = viewport.width;
                pdfCanvas.height = viewport.height;
                pageContainer.appendChild(pdfCanvas);
                
                // Render PDF page to canvas
                const renderContext = {
                    canvasContext: pdfCanvas.getContext('2d'),
                    viewport: viewport
                };
                
                await page.render(renderContext).promise;
                
                // Create a container for fabric canvas
                const fabricCanvasContainer = document.createElement('div');
                fabricCanvasContainer.className = 'fabric-canvas-container';
                fabricCanvasContainer.style.width = `${viewport.width}px`;
                fabricCanvasContainer.style.height = `${viewport.height}px`;
                pageContainer.appendChild(fabricCanvasContainer);
                
                // Create fabric.js canvas for annotations
                const fCanvas = new fabric.Canvas(null, {
                    containerClass: '',
                    width: viewport.width,
                    height: viewport.height,
                    selection: true,
                    preserveObjectStacking: true
                });
                
                // Set Fabric canvas element and append to container
                fCanvas.initialize(document.createElement('canvas'), {
                    width: viewport.width,
                    height: viewport.height,
                });
                fabricCanvasContainer.appendChild(fCanvas.wrapperEl);
                
                // Store page number for reference
                fCanvas.pageNum = pageNum;
                fabricCanvases.push(fCanvas);
                
                // Ensure canvas is properly sized
                fCanvas.setWidth(viewport.width);
                fCanvas.setHeight(viewport.height);
                
                // Add event listeners for this canvas
                setupCanvasListeners(fCanvas, pageContainer);
                
            } catch (error) {
                console.error(`Error rendering page ${pageNum}:`, error);
                updateStatus(`Error rendering page ${pageNum}: ${error.message}`);
            }
        }
        
        // Set up event listeners for Fabric canvas
        function setupCanvasListeners(canvas, container) {
            canvas.on('mouse:down', function(options) {
                if (!currentTool || currentTool === 'eraser') return;
                
                isDrawing = true;
                const pointer = canvas.getPointer(options.e);
                startX = pointer.x;
                startY = pointer.y;
                
                switch(currentTool) {
                    case 'text':
                        // Create text box at click position with current font settings
                        currentTextBox = new fabric.IText('Click to type', {
                            left: startX,
                            top: startY,
                            fontFamily: fontFamily,
                            fontSize: fontSize,
                            fill: fontColor,
                            width: 150,
                            editable: true
                        });
                        canvas.add(currentTextBox);
                        canvas.setActiveObject(currentTextBox);
                        currentTextBox.enterEditing();
                        currentTextBox.selectAll();
                        objectsHistory.push({canvas: canvas, object: currentTextBox, action: 'add'});
                        break;
                        
                    case 'red-box':
                    case 'red-arrow':
                        // These will be handled on mouse:move and mouse:up
                        break;
                        
                    case 'image':
                        if (imageFile && !isImagePlacement) {
                            placeImage(canvas, pointer);
                        }
                        break;
                }
            });
            
            canvas.on('mouse:move', function(options) {
                if (!isDrawing || !currentTool || currentTool === 'eraser') return;
                
                const pointer = canvas.getPointer(options.e);
                
                switch(currentTool) {
                    case 'red-box':
                        // Update red box size
                        if (currentTextBox) {
                            canvas.remove(currentTextBox);
                        }
                        
                        currentTextBox = new fabric.Rect({
                            left: Math.min(startX, pointer.x),
                            top: Math.min(startY, pointer.y),
                            width: Math.abs(startX - pointer.x),
                            height: Math.abs(startY - pointer.y),
                            stroke: 'red',
                            strokeWidth: 2,
                            fill: 'transparent'
                        });
                        
                        canvas.add(currentTextBox);
                        canvas.renderAll();
                        break;
                        
                    case 'red-arrow':
                        // Update arrow line
                        if (currentTextBox) {
                            canvas.remove(currentTextBox);
                        }
                        
                        // Draw line
                        const line = new fabric.Line([startX, startY, pointer.x, pointer.y], {
                            stroke: 'red',
                            strokeWidth: 2
                        });
                        
                        // Calculate arrow head points
                        const headLength = 15;
                        const angle = Math.atan2(pointer.y - startY, pointer.x - startX);
                        const angle1 = angle - Math.PI / 6;
                        const angle2 = angle + Math.PI / 6;
                        
                        const head1X = pointer.x - headLength * Math.cos(angle1);
                        const head1Y = pointer.y - headLength * Math.sin(angle1);
                        const head2X = pointer.x - headLength * Math.cos(angle2);
                        const head2Y = pointer.y - headLength * Math.sin(angle2);
                        
                        // Create arrow head
                        const head1 = new fabric.Line([pointer.x, pointer.y, head1X, head1Y], {
                            stroke: 'red',
                            strokeWidth: 2
                        });
                        
                        const head2 = new fabric.Line([pointer.x, pointer.y, head2X, head2Y], {
                            stroke: 'red',
                            strokeWidth: 2
                        });
                        
                        // Group line and arrow head
                        currentTextBox = new fabric.Group([line, head1, head2], {
                            selectable: true
                        });
                        
                        canvas.add(currentTextBox);
                        canvas.renderAll();
                        break;
                }
            });
            
            canvas.on('mouse:up', function() {
                if (!isDrawing || !currentTool || currentTool === 'eraser') return;
                
                isDrawing = false;
                
                switch(currentTool) {
                    case 'red-box':
                    case 'red-arrow':
                        if (currentTextBox) {
                            objectsHistory.push({canvas: canvas, object: currentTextBox, action: 'add'});
                            currentTextBox = null;
                        }
                        break;
                }
            });
            
            // Enable object manipulation after placement
            canvas.on('object:modified', function(options) {
                updateStatus('Object modified');
            });
            
            // Handle text selection to update font controls
            canvas.on('selection:created', function(options) {
                const activeObject = options.selected[0];
                if (activeObject && activeObject.type === 'i-text') {
                    // Update font controls to match selected text
                    fontFamilySelect.value = activeObject.fontFamily;
                    fontSizeSelect.value = activeObject.fontSize;
                    fontColorSelect.value = activeObject.fill;
                    
                    // Update local variables
                    fontFamily = activeObject.fontFamily;
                    fontSize = activeObject.fontSize;
                    fontColor = activeObject.fill;
                    
                    // Show text options
                    textOptions.classList.add('active');
                }
            });
            
            canvas.on('selection:cleared', function() {
                // Reset to current tool view
                if (currentTool === 'text') {
                    textOptions.classList.add('active');
                } else {
                    textOptions.classList.remove('active');
                }
            });
        }
        
        // Handle image input
        function handleImageInput(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            imageFile = file;
            updateStatus('Image loaded. Click on the canvas to place it.');
        }
        
        // Place image on canvas
        function placeImage(canvas, pointer) {
            if (!imageFile) return;
            isImagePlacement = true;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                fabric.Image.fromURL(e.target.result, function(img) {
                    // Calculate initial dimensions for the image
                    const canvasWidth = canvas.getWidth();
                    const canvasHeight = canvas.getHeight();
                    
                    // Set initial size to 25% of canvas width while maintaining aspect ratio
                    const maxWidth = canvasWidth * 0.25;
                    let width = img.width;
                    let height = img.height;
                    
                    if (width > maxWidth) {
                        const ratio = maxWidth / width;
                        width = maxWidth;
                        height = height * ratio;
                    }
                    
                    img.set({
                        left: pointer.x,
                        top: pointer.y,
                        cornerSize: 10,
                        cornerColor: 'blue',
                        borderColor: 'blue',
                        cornerStyle: 'circle',
                        transparentCorners: false,
                        lockUniScaling: false,
                        hasControls: true,
                        hasBorders: true,
                        selectable: true
                    });
                    
                    // Set the image's scaled dimensions
                    img.scaleToWidth(width);
                    
                    canvas.add(img);
                    canvas.setActiveObject(img);
                    canvas.renderAll();
                    
                    // Store for undo
                    objectsHistory.push({canvas: canvas, object: img, action: 'add'});
                    
                    // Reset tool after placing image
                    currentTool = null;
                    resetToolButtons();
                    isImagePlacement = false;
                    updateStatus('Image placed. You can now resize and move it.');
                });
            };
            reader.readAsDataURL(imageFile);
        }
        
        // Reset active state for all tool buttons
        function resetToolButtons() {
            textToolBtn.classList.remove('active');
            imageToolBtn.classList.remove('active');
            redBoxToolBtn.classList.remove('active');
            redArrowToolBtn.classList.remove('active');
            eraserToolBtn.classList.remove('active');
            textOptions.classList.remove('active');
        }
        
        // Undo last action
        function undoLastAction() {
            if (objectsHistory.length === 0) {
                updateStatus('Nothing to undo');
                return;
            }
            
            const lastAction = objectsHistory.pop();
            
            if (lastAction.action === 'add' || lastAction.action === 'remove') {
                lastAction.canvas.remove(lastAction.object);
            } else {
                // Handle other action types if needed
            }
            
            lastAction.canvas.renderAll();
            
            updateStatus('Last action undone');
        }
        
        // Clear all annotations
        function clearAllAnnotations() {
            if (confirm('Clear all annotations?')) {
                fabricCanvases.forEach(canvas => {
                    canvas.clear();
                });
                
                objectsHistory = [];
                updateStatus('All annotations cleared');
            }
        }
        
        // Save PDF with annotations
        async function savePDF() {
            if (!pdfFile || pdfPages.length === 0) {
                updateStatus('No PDF loaded');
                return;
            }
            
            try {
                updateStatus('Preparing PDF for download...');
                
                // Create PDF document using original PDF dimensions
                const { jsPDF } = window.jspdf;
                
                // Get first page for dimensions
                const firstPage = pdfPages[0];
                const viewport = firstPage.getViewport({scale: 1});  // Use scale 1 for original dimensions
                
                const pdf = new jsPDF({
                    orientation: viewport.width > viewport.height ? 'landscape' : 'portrait',
                    unit: 'pt',
                    format: [viewport.width, viewport.height]
                });
                
                // Higher DPI for better quality
                const DPI_SCALE = 3;
                
                // For each page
                for (let i = 0; i < pdfPages.length; i++) {
                    const page = pdfPages[i];
                    const canvas = fabricCanvases[i];
                    
                    // Get page dimensions
                    const viewport = page.getViewport({scale: 1});  // Original size
                    const width = viewport.width;
                    const height = viewport.height;
                    
                    // Add new page (except for first page)
                    if (i > 0) {
                        pdf.addPage([width, height]);
                    } else {
                        // First page handling
                        pdf.deletePage(1); // Delete default page
                        pdf.addPage([width, height]);
                    }
                    
                    // Create a higher resolution temporary canvas for merging PDF and annotations
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = width * DPI_SCALE;
                    tempCanvas.height = height * DPI_SCALE;
                    const ctx = tempCanvas.getContext('2d');
                    ctx.scale(DPI_SCALE, DPI_SCALE);  // Scale for higher resolution
                    
                    // Render PDF page to the temporary canvas with higher quality
                    const renderContext = {
                        canvasContext: ctx,
                        viewport: viewport
                    };
                    
                    await page.render(renderContext).promise;
                    
                    // Create a high-resolution version of the fabric canvas
                    const fabricDataURL = canvas.toDataURL({
                        format: 'png',
                        quality: 1.0,
                        multiplier: DPI_SCALE / 1.5  // Adjust for original scale factor
                    });
                    
                    // Create an image from fabric canvas
                    const img = new Image();
                    
                    await new Promise((resolve) => {
                        img.onload = resolve;
                        img.src = fabricDataURL;
                    });
                    
                    // Draw annotations on the temporary canvas
                    ctx.drawImage(img, 0, 0, width, height);
                    
                    // Add the combined image to the PDF with high quality
                    const pageDataUrl = tempCanvas.toDataURL('image/jpeg', 1.0);  // Max quality
                    pdf.addImage(pageDataUrl, 'JPEG', 0, 0, width, height, undefined, 'NONE');
                }
                
                // Save the PDF
                const filename = pdfFile.name.replace('.pdf', '_edited.pdf');
                pdf.save(filename);
                
                updateStatus(`PDF saved as ${filename}`);
            } catch (error) {
                console.error('Error saving PDF:', error);
                updateStatus('Error saving PDF: ' + error.message);
            }
        }
        
        // Update status message
        function updateStatus(message) {
            statusEl.textContent = message;
            console.log(message); // Also log to console for debugging
        }
    </script>
</body>
</html>
